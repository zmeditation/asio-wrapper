
#ifndef MAX_OBJECT_NUM
#define MAX_OBJECT_NUM				4096
#endif

#ifndef REUSE_OBJECT
	#ifndef SOCKET_FREE_INTERVAL
	#define SOCKET_FREE_INTERVAL	10
释放（从内存中删除）已经关闭的连接的扫描频率，单位为秒。
如果开启了对象重用，本功能不工作，但使用者仍然可以自己调用free_object来释放指定数量的已经关闭的连接。
	#endif
#endif

#ifdef AUTO_CLEAR_CLOSED_SOCKET
自动清除（从对象池移出到临时链表）已经关闭的连接，这个功能有什么用呢？
如果在连接断开时，你没有或者不想去从对象池中删除，那么可以让st_object_pool周期性的查找已经关闭的连接，
然后移出对象池，这样一次遍历可以操作多条连接，对于短连接效率可能会比每条连接断开时都从对象池中移除高。
如果每次连接断开时，你都移除了对象池（请看st_server::del_client），请务必不要定义这个宏。
	#ifndef CLEAR_CLOSED_SOCKET_INTERVAL
	#define CLEAR_CLOSED_SOCKET_INTERVAL	60
清除已经关闭的连接的扫描频率，单位为秒。
	#endif
#endif

#ifndef CLOSED_SOCKET_MAX_DURATION
	#define CLOSED_SOCKET_MAX_DURATION	5
已经关闭的连接，多久时间之后，可以重用或者释放，单位为秒。
#endif

namespace st_asio_wrapper
{

对象池类，用于管理正常的和失效的连接，对象重用，定时删除已经关闭的连接等；
注意，只能管理由st_socket派生的对象
template<typename Object>
class st_object_pool: public st_service_pump::i_service, public st_timer
{
public:
	typedef boost::shared_ptr<Object> object_type;
	typedef const object_type object_ctype;

protected:
hash表需要的对象比较类。
	struct st_object_hasher
	{
	public:
		size_t operator()(object_ctype& object_ptr) const;
		size_t operator()(uint_fast64_t id) const;
	};

	struct st_object_equal
	{
	public:
		bool operator()(object_ctype& left, object_ctype& right) const;
		bool operator()(uint_fast64_t id, object_ctype& right) const;
	};

public:
	typedef boost::unordered::unordered_set<object_type, st_object_hasher, st_object_equal> container_type;

protected:
已经关闭的连接，从对象池移出到临时链表时，将按这个结构保存，主要目的是为了记录关闭的时间（以判断是否可以释放或者重用）。
	struct temp_object
	{
		const time_t closed_time;
		object_type object_ptr;

		temp_object(object_ctype& object_ptr_);
		bool is_timeout() const;
		bool is_timeout(time_t now) const;
是否超时（超时之后就可以释放或者重用object_ptr对象了）。
	};

protected:
	st_object_pool(st_service_pump& service_pump_);

	void start();
开始，根据宏开启一些定时器，比如如果未定义REUSE_OBJECT，则开启一个定时器用于定时查找已经关闭的连接。

	void stop();
结束，关闭所有定时器。

	bool add_object(object_ctype& object_ptr);
添加一个对象，注意对象总数不能超过MAX_OBJECT_NUM。

	bool del_object(object_ctype& object_ptr);
清除一个对象（从对象池移出到临时链表，并不真正的从内存中释放该对象）。

	virtual void post_create(object_ctype& object_ptr);
每次创建（包括重用）一个对象之后，会调用这个函数，使用者可以利用这个机会（重写这个虚函数），在对象池级别
对新创建的对象做一些必要的设置（最典型的就是设置对象的ID，不过这个工作已经在st_object_pool::post_create里面做了，
所以如果要做你自己的设置，必须在重写的post_create函数中调用父类的post_create函数）。

#ifdef ST_ASIO_REUSE_OBJECT
	object_type reuse_object();
查找可重用的对象，如果没有，返回空的智能指针。能被重用的对象必需是：
 1. 已经从对象池移到了临时链表里面；
 2. 关闭超过一定的时间（CLOSED_SOCKET_MAX_DURATION）；
 3. 对象的引用记数（对象是一个shared_ptr）必须是1；
 4. 对象的obsoleted函数必须返回true。
#endif

public:
	object_type create_object();
如果定义了ST_ASIO_REUSE_OBJECT宏，则先调用reuse_object尝试重用对象，如果没有对象可被重用，或者未定义该宏，
则创建一个新的，最后都是调用post_create。

	template<typename Arg>
	object_type create_object(Arg& arg);
ssl使用，行为和上一个重载一样。

	container_type& container();
用于配置unordered_set，比如设置负载因子，预分配空间等。注意必须在service_pump启动之前调用，因为没有锁相应的mutex。

	size_t max_size() const;
	void max_size(size_t _max_size);
对象池最大容量，可运行时修改。占用内存是动态分配的，只有有效的对象（包括等待被重用的对象）会占用内存。

	size_t size();
对象池中的对象个数，不包括被移除到临时链表的对象。

	size_t closed_object_size();
获取无效对象总数（临时链表里面的对象），无效对象要么定时被删除，要么等待被重用，由宏控制。

	object_type at(size_t index);
获取指定位置的有效对象（连接池中的对象），位置序号从0开始。

	object_type closed_object_at(size_t index);
获取指定位置的无效对象，位置序号从0开始。

	object_type find(uint_fast64_t id);
根据id查找有效对象。

	object_type closed_object_find(uint_fast64_t id);
根据id查找无效对象。

	object_type closed_object_pop(uint_fast64_t id);
根据id查找无效对象，并且从容器中删除。

	void list_all_object();
列出所有有效对象。

	void clear_all_closed_object(container_type& objects);
删除对象池里面的所有无效对象（移出到临时链表）。

	void free_object(size_t num = -1);
释放指定数量的无效对象，如果对象重用开启，则无效对象永远不会释放（而是等待被重用），在某些情况下，你可能不需要
这么多等待被重用的无效对象，可以用这个函数来释放一些无效对象。

	template<typename _Predicate> void do_something_to_all(const _Predicate& __pred);
	template<typename _Predicate> void do_something_to_one(const _Predicate& __pred);
与st_timer的同名函数类似，只操作有效对象。

protected:
	boost::atomic_uint_fast64_t cur_id;
当前已经分配到哪个id了，用于为每一个通过st_object_pool::create_object创建的对象分配一个唯一的id。

	container_type object_can;
	boost::shared_mutex object_can_mutex;
存放有效对象（对象池）。

	boost::container::list<temp_object> temp_object_can;
	boost::shared_mutex temp_object_can_mutex;
存放无效对象（临时链表）。
};

} //namespace

